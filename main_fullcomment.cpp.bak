#include <iostream>
#include <assert.h>

#define ON 1
<<<<<<< HEAD
#define INSERTION_BALANCE ON	// »ðÀÔ ¹ë·±½Ì »ç¿ëÇÒÁö
=======
#define INSERTION_BALANCE ON	// ì‚½ìž… ë°¸ëŸ°ì‹± ì‚¬ìš©í• ì§€
>>>>>>> 2a4618dd6751cbe52653ab82f1bb90535216e1bc

#if INSERTION_BALANCE == ON
#define DELETION_BALANCE ON		// ì‚­ì œ ë°¸ëŸ°ì‹± ì‚¬ìš©í• ì§€
#endif

#define DeleteSafe(x)			\
do {							\
	if (x) {					\
		delete x;				\
	}							\
	x = nullptr;				\
} while (0);		


namespace AVL {

struct Node
{
	int Data = 0;
	Node* Left = nullptr;
	Node* Right = nullptr;
	Node* Parent = nullptr;

	Node* Any() {
		if (Left) {
			return Left;
		}

		if (Right) {
			return Right;
		}

		return nullptr;
	}

	int ChildCount() {
		if (Left && Right) {
			return 2;
		}

		if (Left || Right) {
			return 1;
		}

		return 0;
	}

	void DeleteChild(Node* node) {
		if (Left == node) {
			DeleteSafe(Left);
		} else if (Right == node) {
			DeleteSafe(Right);
		} else {
			assert("¸ù¹Ì?");
		}
	}
};

class AVLTree
{
public:
	AVLTree() {
		m_pVirtualRoot = new Node;
		m_iSize = 0;
	}
	~AVLTree() {
		Clear();
		DeleteSafe(m_pVirtualRoot);
	}
public:
	void Add(int data) {
		if (m_iSize == 0) {
			m_pVirtualRoot->Left = new Node{ data };
			m_pVirtualRoot->Left->Parent = m_pVirtualRoot;
			m_iSize++;
			return;
		}

		Node* pNewNode = Add(m_pVirtualRoot->Any(), data);
	#if INSERTION_BALANCE == ON
		BalanceStart(pNewNode);
	#endif
		m_iSize++;
	}

	bool Remove(int data) {
		Node* pDel = FindNode(data);	// ì‚­ì œí•  ë…¸ë“œë¥¼ ì°¾ëŠ”ë‹¤.

		// ì‚­ì œí•  ë…¸ë“œë¥¼ ëª»ì°¾ì€ ê²½ìš°
		if (pDel == nullptr) {
			return false;
		}

		Node* pBalanceStartingNode = nullptr;	// ë°¸ëŸ°ì‹±ì„ ì§„í–‰í•  ë…¸ë“œ = ì‹¤ì§ˆì ìœ¼ë¡œ ì‚­ì œëœ ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œ
		int iChildCount = pDel->ChildCount();

		if (iChildCount == 0) {
			pBalanceStartingNode = RemoveDelNoChild(pDel);
		} else if (iChildCount == 1) {
			pBalanceStartingNode = RemoveDelOneChild(pDel);
		} else {
			pBalanceStartingNode = RemoveDelTwoChild(pDel);
		}

	#if DELETION_BALANCE == ON
		if (pBalanceStartingNode)
			BalanceStart(pBalanceStartingNode);
	#endif
		m_iSize--;
		return true;
	}

	bool Find(int data) {
		return FindNode(data) != nullptr;
	}

	void Clear() {
		Node* pRoot = m_pVirtualRoot->Any();

		if (pRoot == nullptr) {
			return;
		}

		DeleteElementRecursive(pRoot->Left);
		DeleteElementRecursive(pRoot->Right);
		DeleteSafe(pRoot);
	}
private:
	Node* Add(Node* root, int data) {
		Node* pParent = nullptr;
		Node* pCur = root;
		Node* pNewNode = new Node{ data };
		int iComp = 0;

		while (pCur != nullptr) {
			iComp = Compare(pCur->Data, data);
			pParent = pCur;
			pCur = iComp > 0 ? pCur->Right : pCur->Left;
		}

		if (iComp <= 0) {
			pParent->Left = pNewNode;
			pParent->Left->Parent = pParent;
		} else {
			pParent->Right = pNewNode;
			pParent->Right->Parent = pParent;
		}

		return pNewNode;
	}

	void DeleteElementRecursive(Node* node) {
		if (node == nullptr) {
			return;
		}

		DeleteElementRecursive(node->Left);
		DeleteElementRecursive(node->Right);
		DeleteSafe(node);
	}

	Node* RemoveDelNoChild(Node* del) {
		// 1. ì‚­ì œí•  ë…¸ë“œê°€ ìžì‹ì´ ì—†ëŠ” ê²½ìš°
		//		ë¶€ëª¨ì—ê²Œì„œ í•´ë‹¹ ë…¸ë“œë¥¼ ì—†ì• ì¤€ë‹¤.
		Node* pParent = del->Parent;
		pParent->DeleteChild(del);
		return pParent;
	}

	Node* RemoveDelOneChild(Node* del) {
		// 2. ì‚­ì œí•  ë…¸ë“œê°€ ìžì‹ì´ í•œê°œì¸ ê²½ìš°
		//		1. ì‚­ì œí•  ë…¸ë“œê°€ ë¶€ëª¨ê¸°ì¤€ ìš°ì¸¡ìžì‹ì¸ ê²½ìš°
		//			ì‚­ì œí•  ë…¸ë“œì˜ ìžì‹ì„ ì‚­ì œí•  ë…¸ë“œì˜ ë¶€ëª¨ ìš°ì¸¡ì— ë¶™ì—¬ì¤€ë‹¤.
		//		[ì‚­ì œ ì „]
		//		A - parent
		//			B - del
		//				C
		// 
		//		[ì‚­ì œ í›„]
		//		A - parent
		//			C
		// 
		//		2. ì‚­ì œí•  ë…¸ë“œê°€ ë¶€ëª¨ê¸°ì¤€ ì¢Œì¸¡ìžì‹ì¸ ê²½ìš°
		//			ì‚­ì œí•  ë…¸ë“œì˜ ìžì‹ì„ ì‚­ì œí•  ë…¸ë“œì˜ ë¶€ëª¨ ì¢Œì¸¡ì— ë¶™ì—¬ì¤€ë‹¤.

		Node* pParent = del->Parent;
		Node* pChild = del->Any();
		Node* pBalanceStartingNode = nullptr;


		if (pParent == m_pVirtualRoot) {
			// ì˜ˆì™¸ì²˜ë¦¬ ë§Œì•½ ë¶€ëª¨ê°€ ë²„ì¶”ì–¼ ë…¸ë“œë¼ë©´ ë¬´ì¡°ê±´ ì™¼ìª½ì— ë¶™ì´ë„ë¡í•˜ìž.
			// --> ì²˜ìŒ AVLíŠ¸ë¦¬ ìƒì„±í›„ ë…¸ë“œ ì‚½ìž…í•  ë•Œ ì™¼ìª½ì— ë¬´ì¡°ê±´ ì²« ë…¸ë“œë¥¼ ë¶™ì´ë„ë¡ í–ˆê¸° ë•Œë¬¸
			pParent->Left = pChild;
		} else {
			if (pParent->Right == del) {
				pParent->Right = pChild;
			} else {
				pParent->Left = pChild;
			}
			pBalanceStartingNode = pParent;
		}

		pChild->Parent = pParent;
		DeleteSafe(del);
		return pBalanceStartingNode;
	}

	Node* RemoveDelTwoChild(Node* del) {
		// 3. ì‚­ì œí•  ë…¸ë“œê°€ ìžì‹ì´ 2ê°œì¸ ê²½ìš°
		//		1. ì‚­ì œí•  ë…¸ë“œì˜ ì¢Œì¸¡ ìžì‹ì˜ ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ ì œì¼ í° ë…¸ë“œë¥¼ ì°¾ëŠ”ë‹¤. (ë°©ë²•1)
		//			1. ì œì¼ í° ë…¸ë“œì˜ ê°’ì„ ì‚­ì œí•  ë…¸ë“œì˜ ê°’ì— ëŒ€ìž…í•´ì¤€ë‹¤.
		//			2. ì œì¼ í° ë…¸ë“œì˜ ì¢Œì¸¡ ìžì‹ì„ ì œì¼ í° ë…¸ë“œì˜ ë¶€ëª¨ì˜ ìš°ì¸¡ ìžì‹ìœ¼ë¡œ ë§Œë“¤ì–´ì¤€ë‹¤.
		//			3. ì œì¼ í° ë…¸ë“œë¥¼ ì‚­ì œí•´ì¤€ë‹¤.
		// 
		//		2. ì‚­ì œí•  ë…¸ë“œì˜ ìš°ì¸¡ ìžì‹ì˜ ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ ì œì¼ ìž‘ì€ ë…¸ë“œë¥¼ ì°¾ëŠ”ë‹¤. (ë°©ë²•2)
		//			1. ì œì¼ ìž‘ì€ ë…¸ë“œì˜ ê°’ì„ ì‚­ì œí•  ë…¸ë“œì˜ ê°’ì— ëŒ€ìž…í•´ì¤€ë‹¤.
		//			2. ì œì¼ ìž‘ì€ ë…¸ë“œì˜ ìš°ì¸¡ ìžì‹ì„ ì œì¼ ìž‘ì€ ë…¸ë“œì˜ ë¶€ëª¨ì˜ ì¢Œì¸¡ ìžì‹ìœ¼ë¡œ ë§Œë“¤ì–´ì¤€ë‹¤.
		//			3. ì œì¼ ìž‘ì€ ë…¸ë“œë¥¼ ì‚­ì œí•´ì¤€ë‹¤.

		// --> ë°©ë²•2ë¡œ ì§„í–‰

		Node* pSmallestParent = del;		// ì‚­ì œí•  ë…¸ë“œì˜ ë¶€ëª¨
		Node* pSmallest = del->Right;		// ì‚­ì œí•  ë…¸ë“œ

		while (pSmallest->Left != nullptr) {
			pSmallest = pSmallest->Left;
		}

		pSmallestParent = pSmallest->Parent;
		del->Data = pSmallest->Data;

		if (pSmallestParent->Right == pSmallest) {
			// ìš°ì¸¡ì— ì œì¼ ìž‘ì€ ë…¸ë“œê°€ ë‹¬ë¦°ê²½ìš° 
			// ì´ ê²½ìš°ëŠ” ìœ„ì˜ whileë¬¸ì„ í•œë²ˆë„ ì•ˆëŒ ê²½ìš°ì´ë‹¤.
			//   = "ì‚­ì œí•  ë…¸ë“œë³´ë‹¤ ë” ìž‘ì€ ë…¸ë“œê°€ ì•„ì˜ˆ ì—†ëŠ” ê²½ìš°"

			pSmallestParent->Right = pSmallest->Right;
			if (pSmallest->Right)
				pSmallest->Right->Parent = pSmallestParent;
		} else {
			pSmallestParent->Left = pSmallest->Right;
			if (pSmallest->Right)
				pSmallest->Right->Parent = pSmallestParent;
		}
		DeleteSafe(pSmallest);
		return pSmallestParent;
	}

	void BalanceStart(Node* node) {
		Node* pCur = node;

		while (pCur != m_pVirtualRoot) {
			Balance(pCur);
			pCur = pCur->Parent;
		}
	}

	// í•´ë‹¹ ë…¸ë“œ ê¸°ì¤€ìœ¼ë¡œ ë°¸ëŸ°ì‹± ì§„í–‰
	void Balance(Node* node) {
		int iHeightDiff = GetHeightDiff(node);
		// ìš°ì¸¡ ë†’ì´ê°€ ì¢Œì¸¡ ë†’ì´ë³´ë‹¤ 2ì´ìƒ ë†’ì€ ê²½ìš°
		if (iHeightDiff >= 2) {
			int iChildHeightDiff = GetHeightDiff(node->Right);
			if (iChildHeightDiff >= 1) {
				RotateRR(node);
			} else {
				RotateRL(node);
			}
		} else if (iHeightDiff <= -2) {
			int iChildHeightDiff = GetHeightDiff(node->Left);
			if (iChildHeightDiff <= -1) {
				RotateLL(node);
			} else {
				RotateLR(node);
			}
		}
	}

	Node* FindNode(int data) {
		Node* pCur = m_pVirtualRoot->Any();

		while (pCur != nullptr) {
			if (pCur->Data == data) {
				return pCur;
			}

			if (pCur->Data < data) {
				pCur = pCur->Right;
			} else {
				pCur = pCur->Left;
			}
		}

		return nullptr;
	}

	int GetHeightDiff(Node* node) {
		int iLeftSubtreeHeight = GetHeight(node->Left, 0);
		int iRightSubtreeHeight = GetHeight(node->Right, 0);

		return iRightSubtreeHeight - iLeftSubtreeHeight;
	}

	int GetHeight(Node* cur, int height) {
		if (cur == nullptr) {
			return height;
		}
		int iLeftHeight = GetHeight(cur->Left, height + 1);
		int iRightHeight = GetHeight(cur->Right, height + 1);

		return iLeftHeight > iRightHeight ? iLeftHeight : iRightHeight;
	}


	void RotateRR(Node* cur) {
		//  ?   		- ? : pParent
		//    1 		- 1 : pCur
		//      3		- 3 : pChild
		//    ?	  5  	- ? : pChildLeft

		//  ?			- ? : pParent
		//    3			- 3 : pChild
		//  1   5		- 1 : pCur
		//   ?			- ? : pChildLeft

		Node* pParent = cur->Parent;
		Node* pCur = cur;
		Node* pChild = cur->Right;
		Node* pChildLeft = cur->Right->Left;

		if (pParent->Left == pCur)
			pParent->Left = pChild;
		else
			pParent->Right = pChild;
		pChild->Parent = pParent;


		pCur->Right = pChildLeft;
		if (pChildLeft)
			pChildLeft->Parent = pCur;

		pChild->Left = pCur;
		pCur->Parent = pChild;
	}

	void RotateLR(Node* cur) {
		RotateRR(cur->Left);
		RotateLL(cur);
	}

	void RotateRL(Node* cur) {
		RotateLL(cur->Right);
		RotateRR(cur);
	}

	void RotateLL(Node* cur) {
		//        ?		- pParent
		//      5		- pCur
		//    3			- pChild
		//  1   ?		- pChildRight

		//      ?		- pParent
		//    3			- pChild
		//  1   5		- pCur
		//    ?			- pChildRight

		Node* pParent = cur->Parent;
		Node* pCur = cur;
		Node* pChild = cur->Left;
		Node* pChildRight = cur->Left->Right;

		if (pParent->Left == pCur)
			pParent->Left = pChild;
		else
			pParent->Right = pChild;
		pChild->Parent = pParent;

		pCur->Left = pChildRight;
		if (pChildRight)
			pChildRight->Parent = pCur;

		pChild->Right = pCur;
		pCur->Parent = pChild;
	}


	int Compare(int src, int dst) {
		if (src < dst) {
			return 1;
		}

		if (src > dst) {
			return -1;
		}

		return 0;
	}


private:
	Node* m_pVirtualRoot;
	int m_iSize;
};

} // namespace AVL


int main() {
	AVL::AVLTree tree;

	tree.Add(1);
	tree.Add(2);
	tree.Add(3);
	tree.Add(4);
	tree.Add(5);

	std::cout << std::boolalpha;
	std::cout << "1 ì°¾ê¸° : " << tree.Find(1) << "\n";
	std::cout << "2 ì°¾ê¸° : " << tree.Find(2) << "\n";
	std::cout << "3 ì°¾ê¸° : " << tree.Find(3) << "\n";
	std::cout << "4 ì°¾ê¸° : " << tree.Find(4) << "\n";
	std::cout << "5 ì°¾ê¸° : " << tree.Find(5) << "\n";

	tree.Remove(1);
	tree.Remove(2);
	tree.Remove(3);
	tree.Remove(4);
	tree.Remove(5);


	return 0;
}


